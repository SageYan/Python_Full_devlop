[TOC]

# Python全栈学习（11） 深浅拷贝

## 赋值运算

```python
l1 = [1,2,3,['barry','alex']]
l2 = l1

l1[0] = 111
print(l1)  # [111, 2, 3, ['barry', 'alex']]
print(l2)  # [111, 2, 3, ['barry', 'alex']]

l1[3][0] = 'wusir'
print(l1)  # [111, 2, 3, ['wusir', 'alex']]
print(l2)  # [111, 2, 3, ['wusir', 'alex']]

注释：
对于赋值运算来说，l1与l2指向的是同一个内存地址，所以他们是完全一样的。

```



## 浅拷贝

```python
l1 = [1, '太白', True, (1,2,3), [22, 33]]
l2 = l1.copy()

print(id(l1), id(l2))  #1558057699848 1558057725320
#PS:
​```
列表（可变数据类型）的在内存中的表现形式是，不保留实际数据，而是以槽位的形式保留实际数据对应的内存地址。
因此浅拷贝后会内存中会开辟出一个新的列表，而槽位中对应的内存地址和原始列表相同。
​```
print(id(l1[0]), id(l2[0])) #1437598160 1437598160
print(id(l1[-1]), id(l2[-1])) #1558057722824 1558057722824
#槽位指向的内存地址一致

l1[0] = 123
print(l1, l2)
l1[-1].append('abc')
print(l1, l2)
#结果：
[123, '太白', True, (1, 2, 3), [22, 33]] [1, '太白', True, (1, 2, 3), [22, 33]]
PS：
​```
l1修改了0位槽位保留的 “不可变数据类型的内存地址” 指向，不影响l2的0槽位保存的内存地址指向。
​```
[123, '太白', True, (1, 2, 3), [22, 33, 'abc']] [1, '太白', True, (1, 2, 3), [22, 33, 'abc']]
​```
对于可变数据类型的修改，并不会改变内存地址的指向。因此,l1和l2都收到影响。
​```
```



## 深拷贝

```python
import copy
l1 = [1, 'alex', True, (1,2,3), [22, 33]]
l2 = copy.deepcopy(l1)
print(id(l1), id(l2))  # 2788324482440 2788324483016
print(id(l1[0]),id(l2[0]))  # 1470562768 1470562768
print(id(l1[-1]),id(l2[-1]))  # 2788324482632 2788324482696
#注释：
​```
对于深copy来说，列表是在内存中重新创建的，列表中可变的数据类型是重新创建的，列表中的不可变的数据类型是公用的。
​```
print(id(l1[-2]),id(l2[-2]))  # 2788323047752 2788323047752
```

